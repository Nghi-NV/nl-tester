//! YAML Generator for converting recorded actions to test scripts
//!
//! This module generates well-formatted YAML test files from recorded actions,
//! including helpful comments with selector alternatives and scores.

use chrono::Local;
use std::io::Write;
use std::path::Path;

use super::event_recorder::RecordedAction;
use super::selector_scorer::SelectorCandidate;

/// YAML Generator configuration
#[derive(Debug, Clone)]
pub struct YamlGeneratorConfig {
    /// Include comments with selector alternatives
    pub include_comments: bool,
    /// Include timing waits between actions
    pub include_waits: bool,
    /// Minimum wait to include (ms)
    pub min_wait_ms: u64,
    /// Mask passwords/sensitive data
    pub mask_sensitive: bool,
    /// Add assertions after navigation
    pub suggest_assertions: bool,
}

impl Default for YamlGeneratorConfig {
    fn default() -> Self {
        Self {
            include_comments: true,
            include_waits: true,
            min_wait_ms: 1000,
            mask_sensitive: true,
            suggest_assertions: true,
        }
    }
}

/// YAML test script generator
pub struct YamlGenerator {
    config: YamlGeneratorConfig,
}

impl YamlGenerator {
    /// Create a new generator with default config
    pub fn new() -> Self {
        Self {
            config: YamlGeneratorConfig::default(),
        }
    }

    /// Create a generator with custom config
    pub fn with_config(config: YamlGeneratorConfig) -> Self {
        Self { config }
    }

    /// Generate YAML content from recorded actions
    pub fn generate(
        &self,
        actions: &[RecordedAction],
        app_id: Option<&str>,
        name: Option<&str>,
    ) -> String {
        let mut output = String::new();

        // Header section
        output.push_str(&self.generate_header(app_id, name));
        output.push_str("---\n");

        // Steps
        let mut prev_timestamp = None;
        let mut step_num = 0;

        for action in actions {
            step_num += 1;

            // Add wait if there was a significant pause
            if self.config.include_waits {
                if let Some(prev) = prev_timestamp {
                    let elapsed = action.timestamp().duration_since(prev).as_millis() as u64;
                    if elapsed >= self.config.min_wait_ms {
                        output.push_str(&format!("\n# Wait {}ms\n", elapsed));
                        output.push_str(&format!("- wait: {}\n", elapsed));
                    }
                }
            }

            // Generate step
            output.push_str(&format!("\n# Step {}\n", step_num));
            output.push_str(&self.generate_step(action));

            prev_timestamp = Some(action.timestamp());
        }

        output
    }

    /// Generate the YAML header section
    fn generate_header(&self, app_id: Option<&str>, name: Option<&str>) -> String {
        let mut header = String::new();

        if let Some(name) = name {
            header.push_str(&format!("name: \"{}\"\n", name));
        } else {
            header.push_str("name: \"Recorded Test\"\n");
        }

        if let Some(app_id) = app_id {
            header.push_str(&format!("appId: {}\n", app_id));
        }

        header.push_str(&format!(
            "# ðŸ¤– Auto-generated by lumi-tester record\n# ðŸ“… {}\n",
            Local::now().format("%Y-%m-%dT%H:%M:%S%z")
        ));

        header
    }

    /// Generate YAML for a single action
    fn generate_step(&self, action: &RecordedAction) -> String {
        match action {
            RecordedAction::Tap {
                element, selectors, ..
            } => self.generate_tap_step(selectors),

            RecordedAction::LongPress {
                selectors,
                duration_ms,
                ..
            } => self.generate_long_press_step(selectors, *duration_ms),

            RecordedAction::Input {
                selectors, text, ..
            } => self.generate_input_step(selectors, text),

            RecordedAction::Swipe { direction, .. } => {
                format!("- swipe: \"{}\"\n", direction)
            }

            RecordedAction::Wait { duration_ms, .. } => {
                format!("- wait: {}\n", duration_ms)
            }

            RecordedAction::OpenApp { app_id, .. } => {
                format!("- open: \"{}\"\n", app_id)
            }
        }
    }

    /// Generate tap step with smart selector
    fn generate_tap_step(&self, selectors: &[SelectorCandidate]) -> String {
        let mut output = String::new();

        if let Some(best) = selectors.first() {
            // Add comment with selector info
            if self.config.include_comments && selectors.len() > 1 {
                let alts: Vec<String> = selectors[1..]
                    .iter()
                    .take(2)
                    .map(|s| s.short_repr())
                    .collect();

                output.push_str(&format!(
                    "# Selector: {} (score: {}) | Alt: {}\n",
                    best.selector_type,
                    best.score,
                    alts.join(", ")
                ));

                // Add warning if selector is unstable
                if !best.is_stable {
                    output.push_str("# âš ï¸ WARNING: This selector may be unstable. Consider asking dev to add a resource-id.\n");
                }
            }

            output.push_str(&best.to_yaml("tap"));
            output.push('\n');
        } else {
            output.push_str("# âš ï¸ No valid selector found\n- tap:\n    point: \"50%,50%\"\n");
        }

        output
    }

    /// Generate long press step
    fn generate_long_press_step(
        &self,
        selectors: &[SelectorCandidate],
        duration_ms: u64,
    ) -> String {
        let mut output = String::new();

        if let Some(best) = selectors.first() {
            if self.config.include_comments {
                output.push_str(&format!(
                    "# Selector: {} (score: {})\n",
                    best.selector_type, best.score
                ));
            }

            // Long press format
            match best.selector_type.as_str() {
                "id" => {
                    output.push_str(&format!(
                        "- longPress:\n    id: \"{}\"\n    duration: {}\n",
                        best.value, duration_ms
                    ));
                }
                "text" => {
                    output.push_str(&format!(
                        "- longPress:\n    text: \"{}\"\n    duration: {}\n",
                        best.value, duration_ms
                    ));
                }
                _ => {
                    output.push_str(&format!(
                        "- longPress:\n    {}: \"{}\"\n    duration: {}\n",
                        best.selector_type, best.value, duration_ms
                    ));
                }
            }
        }

        output
    }

    /// Generate input step with masking for sensitive data
    fn generate_input_step(&self, selectors: &[SelectorCandidate], text: &str) -> String {
        let mut output = String::new();

        // Detect and mask sensitive data
        let (display_text, is_sensitive) = if self.config.mask_sensitive {
            self.mask_sensitive_text(text)
        } else {
            (text.to_string(), false)
        };

        if let Some(best) = selectors.first() {
            if self.config.include_comments {
                output.push_str(&format!(
                    "# Selector: {} (score: {})\n",
                    best.selector_type, best.score
                ));
                if is_sensitive {
                    output.push_str(
                        "# ðŸ”’ Sensitive data masked. Replace with actual value or use variable.\n",
                    );
                }
            }

            match best.selector_type.as_str() {
                "id" => {
                    output.push_str(&format!(
                        "- inputText:\n    id: \"{}\"\n    text: \"{}\"\n",
                        best.value, display_text
                    ));
                }
                "text" => {
                    // For text input, we usually select by the current value or nearby label
                    output.push_str(&format!(
                        "- inputText:\n    text: \"{}\"\n    value: \"{}\"\n",
                        best.value, display_text
                    ));
                }
                _ => {
                    output.push_str(&format!(
                        "- inputText:\n    {}: \"{}\"\n    text: \"{}\"\n",
                        best.selector_type, best.value, display_text
                    ));
                }
            }
        }

        output
    }

    /// Mask sensitive data (passwords, tokens, etc.)
    fn mask_sensitive_text(&self, text: &str) -> (String, bool) {
        // Check for password patterns
        if text.len() >= 6 && !text.contains(' ') {
            // Could be a password if it has mixed chars or is all the same type
            let has_digits = text.chars().any(|c| c.is_ascii_digit());
            let has_alpha = text.chars().any(|c| c.is_alphabetic());

            if has_digits && has_alpha {
                return ("********".to_string(), true);
            }
        }

        // Check for pure numeric (could be PIN/OTP)
        if text.len() >= 4 && text.chars().all(|c| c.is_ascii_digit()) {
            return ("****".to_string(), true);
        }

        (text.to_string(), false)
    }

    /// Save generated YAML to a file
    pub fn save_to_file(
        &self,
        actions: &[RecordedAction],
        app_id: Option<&str>,
        name: Option<&str>,
        path: &Path,
    ) -> std::io::Result<()> {
        let content = self.generate(actions, app_id, name);

        let mut file = std::fs::File::create(path)?;
        file.write_all(content.as_bytes())?;

        println!("âœ… Saved {} steps to: {}", actions.len(), path.display());

        Ok(())
    }
}

impl Default for YamlGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::driver::android::uiautomator::{Bounds, UiElement};
    use std::time::Instant;

    #[test]
    fn test_generate_simple_tap() {
        let generator = YamlGenerator::new();

        let element = UiElement {
            class: "Button".to_string(),
            text: "Login".to_string(),
            resource_id: "com.app:id/btn_login".to_string(),
            content_desc: "".to_string(),
            bounds: Bounds {
                left: 0,
                top: 0,
                right: 100,
                bottom: 50,
            },
            clickable: true,
            enabled: true,
            focusable: true,
        };

        let selectors = vec![
            SelectorCandidate {
                selector_type: "id".to_string(),
                value: "com.app:id/btn_login".to_string(),
                score: 100,
                reason: "Stable ID".to_string(),
                is_stable: true,
            },
            SelectorCandidate {
                selector_type: "text".to_string(),
                value: "Login".to_string(),
                score: 80,
                reason: "Text".to_string(),
                is_stable: true,
            },
        ];

        let actions = vec![RecordedAction::Tap {
            element,
            selectors,
            timestamp: Instant::now(),
        }];

        let yaml = generator.generate(&actions, Some("com.example.app"), Some("Login Test"));

        assert!(yaml.contains("name: \"Login Test\""));
        assert!(yaml.contains("appId: com.example.app"));
        assert!(yaml.contains("id: \"com.app:id/btn_login\""));
    }

    #[test]
    fn test_mask_password() {
        let generator = YamlGenerator::new();

        let (masked, is_sensitive) = generator.mask_sensitive_text("MyP@ss123");
        assert!(is_sensitive);
        assert_eq!(masked, "********");

        let (masked2, is_sensitive2) = generator.mask_sensitive_text("Hello World");
        assert!(!is_sensitive2);
        assert_eq!(masked2, "Hello World");
    }
}
